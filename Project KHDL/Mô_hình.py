# -*- coding: utf-8 -*-
"""Mô hình.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lOjvo2YOzXlAYplwhA4EYQpo4HEBkEbs
"""

#Mô tả dữ liệu

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import mean_squared_error, r2_score
import tensorflow as tf
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense

# Đọc dữ liệu từ tệp CSV
df = pd.read_csv('Dataa_Service.csv')
print(df.head())
print(df.describe())
# Kiểm tra giá trị thiếu trong dữ liệu
print('Giá trị bị thiếu')
print(df.isnull().sum())

#Mô hình hồi quy
import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_squared_error
from sklearn.metrics import mean_absolute_error, r2_score
from sklearn.linear_model import Ridge
from sklearn.linear_model import Lasso
from sklearn.tree import DecisionTreeRegressor
import time

# Đọc dữ liệu từ tệp CSV
df = pd.read_csv('Dataa_Service.csv')

# Tách biến đầu vào và biến mục tiêu
X = df[['Month', 'Year', 'CPI','GDP','Temperature','USD/VND']]
y = df['Service']

# Chia dữ liệu thành tập huấn luyện và tập kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=20)

# Chuẩn hóa dữ liệu
scaler = StandardScaler()
X_train = scaler.fit_transform(X_train)
X_test = scaler.transform(X_test)

#MODEL1 Xây dựng mô hình ( Linear Regression )
start_time = time.time()
model = LinearRegression()
model.fit(X_train, y_train)
y_pred = model.predict(X_test)
end_time = time.time()
linear_regression_time = end_time - start_time

#MODEL2 Xây dựng mô hình ( Ridge Regression )
start_time = time.time()
ridge_model = Ridge(alpha=1.0)
ridge_model.fit(X_train, y_train)
ridge_y_pred = ridge_model.predict(X_test)
end_time = time.time()
ridge_regression_time = end_time - start_time

#MODEL3 Xây dựng mô hình (Lasso Regression)
start_time = time.time()
lasso_model = Lasso(alpha=1.0)
lasso_model.fit(X_train, y_train)
lasso_y_pred = lasso_model.predict(X_test)
end_time = time.time()
lasso_regression_time = end_time - start_time

#MODEL4 Xây dựng mô hình Decision Tree Regression
start_time = time.time()
tree_model = DecisionTreeRegressor(random_state=20)
tree_model.fit(X_train, y_train)
tree_y_pred = tree_model.predict(X_test)
end_time = time.time()
tree_regression_time = end_time - start_time

#Đánh giá mô hình bằng 4 chỉ số hồi quy
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
rmse = np.sqrt(mean_squared_error(y_test, y_pred))
mpae = np.mean(np.abs((y_test - y_pred) / y_test)) * 100

ridge_mae = mean_absolute_error(y_test, ridge_y_pred)
ridge_r2 = r2_score(y_test, ridge_y_pred)
ridge_rmse = np.sqrt(mean_squared_error(y_test, ridge_y_pred))
ridge_mpae = np.mean(np.abs((y_test - ridge_y_pred) / y_test)) * 100

lasso_mae = mean_absolute_error(y_test, lasso_y_pred)
lasso_r2 = r2_score(y_test, lasso_y_pred)
lasso_rmse = np.sqrt(mean_squared_error(y_test, lasso_y_pred))
lasso_mpae = np.mean(np.abs((y_test - lasso_y_pred) / y_test)) * 100

tree_mae = mean_absolute_error(y_test, tree_y_pred)
tree_r2 = r2_score(y_test, tree_y_pred)
tree_rmse = np.sqrt(mean_squared_error(y_test, tree_y_pred))
tree_mpae = np.mean(np.abs((y_test - tree_y_pred) / y_test)) * 100

print("Mean Absolute Error (MAE):", mae)
print("R-squared (R2):", r2)
print("Root Mean Squared Error (RMSE):", rmse)
print("Mean Percentage Absolute Error (MPAE):", mpae)
print("Time taken (seconds):", linear_regression_time)

print("Mean Absolute Error (MAE):", ridge_mae)
print("R-squared (R2):", ridge_r2)
print("Root Mean Squared Error (RMSE):", ridge_rmse)
print("Mean Percentage Absolute Error (MPAE):", ridge_mpae)
print("Time taken (seconds):", ridge_regression_time)

print("Mean Absolute Error (MAE):", lasso_mae)
print("R-squared (R2):", lasso_r2)
print("Root Mean Squared Error (RMSE):", lasso_rmse)
print("Mean Percentage Absolute Error (MPAE):", lasso_mpae)
print("Time taken (seconds):", lasso_regression_time)

print("Mean Absolute Error (MAE):", tree_mae)
print("R-squared (R2):", tree_r2)
print("Root Mean Squared Error (RMSE):", tree_rmse)
print("Mean Percentage Absolute Error (MPAE):", tree_mpae)
print("Time taken (seconds):", tree_regression_time)

#Mạng Nowrron nhiều lớp
import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error
from keras.models import Sequential
from keras.layers import Dense

# Đọc dữ liệu từ tệp CSV
df = pd.read_csv('Dataa_Service.csv')

# Chọn các cột đầu vào và đầu ra
X = df[['Month', 'Year', 'CPI', 'GDP', 'Temperature', 'USD/VND']]
y = df['Service']

# Chuẩn hóa dữ liệu
scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()
X_scaled = scaler_X.fit_transform(X)
y_scaled = scaler_y.fit_transform(y.values.reshape(-1, 1))

# Chia dữ liệu thành tập huấn luyện và kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.2, random_state=42)

# Xây dựng mô hình mạng nơron
model = Sequential()
model.add(Dense(64, input_dim=X_train.shape[1], activation='relu'))
model.add(Dense(32, activation='relu'))
model.add(Dense(16, activation='relu'))
model.add(Dense(1))

# Biên dịch mô hình
model.compile(loss='mean_squared_error', optimizer='adam')

# Đo thời gian bắt đầu huấn luyện
start_time = time.time()

# Huấn luyện mô hình
model.fit(X_train, y_train, epochs=5000, batch_size=10, verbose=2)

# Đo thời gian kết thúc huấn luyện
end_time = time.time()

# Dự báo trên tập kiểm tra
y_pred_scaled = model.predict(X_test)

# Chuyển đổi lại dữ liệu về dạng ban đầu
y_pred = scaler_y.inverse_transform(y_pred_scaled)
y_test = scaler_y.inverse_transform(y_test)

# Tính toán các chỉ số đánh giá
mse = np.mean((y_pred - y_test) ** 2)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_test, y_pred)
r2 = r2_score(y_test, y_pred)
mape = mean_absolute_percentage_error(y_test, y_pred)
adjusted_r2 = 1 - (1 - r2) * ((len(y_test) - 1) / (len(y_test) - X_test.shape[1] - 1))

# In các chỉ số đánh giá
print(f'Test RMSE: {rmse:.2f}')
print(f'Test MAE: {mae:.2f}')
print(f'Test R^2: {r2:.2f}')
print(f'Test MAPE: {mape:.2f}')
print(f'Test Adjusted R^2: {adjusted_r2:.2f}')

# In thời gian huấn luyện
print(f'Training Time: {end_time - start_time:.2f} seconds')

#Với Dropout để tránh overfitting

import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error
from keras.models import Sequential
from keras.layers import Dense, Dropout

# Đọc dữ liệu từ tệp CSV
df = pd.read_csv('Dataa_Service.csv')

# Chọn các cột đầu vào và đầu ra
X = df[['Month', 'Year', 'CPI', 'GDP', 'Temperature', 'USD/VND']]
y = df['Service']

# Chuẩn hóa dữ liệu
scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()
X_scaled = scaler_X.fit_transform(X)
y_scaled = scaler_y.fit_transform(y.values.reshape(-1, 1))

# Chia dữ liệu thành tập huấn luyện và kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.2, random_state=42)

# Xây dựng mô hình mạng nơron với Dropout
model2 = Sequential()
model2.add(Dense(128, input_dim=X_train.shape[1], activation='relu'))
model2.add(Dropout(0.5))
model2.add(Dense(64, activation='relu'))
model2.add(Dropout(0.5))
model2.add(Dense(32, activation='relu'))
model2.add(Dense(1))

# Biên dịch mô hình
model2.compile(loss='mean_squared_error', optimizer='adam')

# Đo thời gian bắt đầu huấn luyện
start_time = time.time()

# Huấn luyện mô hình
model2.fit(X_train, y_train, epochs=100, batch_size=10, verbose=2)

# Đo thời gian kết thúc huấn luyện
end_time = time.time()

# Dự báo trên tập kiểm tra
y_pred2_scaled = model2.predict(X_test)

# Chuyển đổi lại dữ liệu về dạng ban đầu
y_pred2 = scaler_y.inverse_transform(y_pred2_scaled)
y_test_inverse = scaler_y.inverse_transform(y_test)

# Tính toán các chỉ số đánh giá
mse2 = np.mean((y_pred2 - y_test_inverse) ** 2)
rmse2 = np.sqrt(mse2)
mae2 = mean_absolute_error(y_test_inverse, y_pred2)
r22 = r2_score(y_test_inverse, y_pred2)
mape2 = mean_absolute_percentage_error(y_test_inverse, y_pred2)
adjusted_r22 = 1 - (1 - r22) * ((len(y_test_inverse) - 1) / (len(y_test_inverse) - X_test.shape[1] - 1))

# In các chỉ số đánh giá
print(f'Model 2 - Test RMSE: {rmse2:.2f}')
print(f'Model 2 - Test MAE: {mae2:.2f}')
print(f'Model 2 - Test R^2: {r22:.2f}')
print(f'Model 2 - Test MAPE: {mape2:.2f}')
print(f'Model 2 - Test Adjusted R^2: {adjusted_r22:.2f}')
print(f'Model 2 - Training Time: {end_time - start_time:.2f} seconds')

#Mô hình với Batch Normalization
import pandas as pd
import numpy as np
import time
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error
from keras.models import Sequential
from keras.layers import Dense, BatchNormalization

# Đọc dữ liệu từ tệp CSV
df = pd.read_csv('Dataa_Service.csv')

# Chọn các cột đầu vào và đầu ra
X = df[['Month', 'Year', 'CPI', 'GDP', 'Temperature', 'USD/VND']]
y = df['Service']

# Chuẩn hóa dữ liệu
scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()
X_scaled = scaler_X.fit_transform(X)
y_scaled = scaler_y.fit_transform(y.values.reshape(-1, 1))

# Chia dữ liệu thành tập huấn luyện và kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.2, random_state=42)

# Xây dựng mô hình mạng nơron với Batch Normalization
model5 = Sequential()
model5.add(Dense(128, input_dim=X_train.shape[1], activation='relu'))
model5.add(BatchNormalization())
model5.add(Dense(64, activation='relu'))
model5.add(BatchNormalization())
model5.add(Dense(32, activation='relu'))
model5.add(BatchNormalization())
model5.add(Dense(1))

# Biên dịch mô hình
model5.compile(loss='mean_squared_error', optimizer='adam')

# Đo thời gian bắt đầu huấn luyện
start_time = time.time()

# Huấn luyện mô hình
model5.fit(X_train, y_train, epochs=100, batch_size=10, verbose=2)

# Đo thời gian kết thúc huấn luyện
end_time = time.time()

# Dự báo trên tập kiểm tra
y_pred5_scaled = model5.predict(X_test)

# Chuyển đổi lại dữ liệu về dạng ban đầu
y_pred5 = scaler_y.inverse_transform(y_pred5_scaled)
y_test_inverse = scaler_y.inverse_transform(y_test)

# Tính toán các chỉ số đánh giá
mse5 = np.mean((y_pred5 - y_test_inverse) ** 2)
rmse5 = np.sqrt(mse5)
mae5 = mean_absolute_error(y_test_inverse, y_pred5)
r25 = r2_score(y_test_inverse, y_pred5)
mape5 = mean_absolute_percentage_error(y_test_inverse, y_pred5)
adjusted_r25 = 1 - (1 - r25) * ((len(y_test_inverse) - 1) / (len(y_test_inverse) - X_test.shape[1] - 1))

# In các chỉ số đánh giá
print(f'Model 5 - Test RMSE: {rmse5:.2f}')
print(f'Model 5 - Test MAE: {mae5:.2f}')
print(f'Model 5 - Test R^2: {r25:.2f}')
print(f'Model 5 - Test MAPE: {mape5:.2f}')
print(f'Model 5 - Test Adjusted R^2: {adjusted_r25:.2f}')
print(f'Model 5 - Training Time: {end_time - start_time:.2f} seconds')

### Mô hình SVM Model 5 6 7
import pandas as pd
import time
import numpy as np
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import mean_absolute_error, r2_score, mean_absolute_percentage_error
from sklearn.svm import SVR

# Đọc dữ liệu từ tệp CSV
df = pd.read_csv('Dataa_Service.csv')

# Chọn các cột đầu vào và đầu ra
X = df[['Month', 'Year', 'CPI', 'GDP', 'Temperature', 'USD/VND']]
y = df['Service']

# Chuẩn hóa dữ liệu
scaler_X = MinMaxScaler()
scaler_y = MinMaxScaler()
X_scaled = scaler_X.fit_transform(X)
y_scaled = scaler_y.fit_transform(y.values.reshape(-1, 1))

# Chia dữ liệu thành tập huấn luyện và tập kiểm tra
X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_scaled, test_size=0.2, random_state=42)

# Xây dựng mô hình SVM với kernel RBF
svm_model = SVR(kernel='rbf')

# Đo thời gian bắt đầu huấn luyện
start_time = time.time()

# Huấn luyện mô hình
svm_model.fit(X_train, y_train.ravel())

# Đo thời gian kết thúc huấn luyện
end_time = time.time()

# Dự đoán trên tập kiểm tra
y_pred = svm_model.predict(X_test)

# Chuyển đổi lại dữ liệu về dạng ban đầu
y_pred = scaler_y.inverse_transform(y_pred.reshape(-1, 1))
y_test_inverse = scaler_y.inverse_transform(y_test)

# Tính toán các chỉ số đánh giá
mse = np.mean((y_pred - y_test_inverse) ** 2)
rmse = np.sqrt(mse)
mae = mean_absolute_error(y_test_inverse, y_pred)
r2 = r2_score(y_test_inverse, y_pred)
mape = mean_absolute_percentage_error(y_test_inverse, y_pred)
adjusted_r2 = 1 - (1 - r2) * ((len(y_test_inverse) - 1) / (len(y_test_inverse) - X_test.shape[1] - 1))

# Xây dựng mô hình SVM với kernel đa thức
svr_poly = SVR(kernel='poly', degree=3)

# Đo thời gian bắt đầu huấn luyện
start_time_poly = time.time()

# Huấn luyện mô hình
svr_poly.fit(X_train, y_train.ravel())

# Đo thời gian kết thúc huấn luyện
end_time_poly = time.time()

# Dự báo trên tập kiểm tra
y_pred_poly = svr_poly.predict(X_test)

# Chuyển đổi lại dữ liệu về dạng ban đầu
y_pred_poly = scaler_y.inverse_transform(y_pred_poly.reshape(-1, 1))
y_test_inverse = scaler_y.inverse_transform(y_test)

# Tính toán các chỉ số đánh giá
mse_poly = np.mean((y_pred_poly - y_test_inverse) ** 2)
rmse_poly = np.sqrt(mse_poly)
mae_poly = mean_absolute_error(y_test_inverse, y_pred_poly)
r2_poly = r2_score(y_test_inverse, y_pred_poly)
mape_poly = mean_absolute_percentage_error(y_test_inverse, y_pred_poly)
adjusted_r2_poly = 1 - (1 - r2_poly) * ((len(y_test_inverse) - 1) / (len(y_test_inverse) - X_test.shape[1] - 1))

# Xây dựng mô hình SVM với kernel tuyến tính (linear)
svr_linear = SVR(kernel='linear')

# Đo thời gian bắt đầu huấn luyện
start_time_linear = time.time()

# Huấn luyện mô hình
svr_linear.fit(X_train, y_train.ravel())

# Đo thời gian kết thúc huấn luyện
end_time_linear = time.time()

# Dự báo trên tập kiểm tra
y_pred_linear = svr_linear.predict(X_test)

# Chuyển đổi lại dữ liệu về dạng ban đầu
y_pred_linear = scaler_y.inverse_transform(y_pred_linear.reshape(-1, 1))
y_test_inverse = scaler_y.inverse_transform(y_test)

# Tính toán các chỉ số đánh giá
mse_linear = np.mean((y_pred_linear - y_test_inverse) ** 2)
rmse_linear = np.sqrt(mse_linear)
mae_linear = mean_absolute_error(y_test_inverse, y_pred_linear)
r2_linear = r2_score(y_test_inverse, y_pred_linear)
mape_linear = mean_absolute_percentage_error(y_test_inverse, y_pred_linear)
adjusted_r2_linear = 1 - (1 - r2_linear) * ((len(y_test_inverse) - 1) / (len(y_test_inverse) - X_test.shape[1] - 1))

# In các chỉ số đánh giá
print("Model with RBF kernel")
print("Training time:", end_time - start_time)
print("RMSE:", rmse)
print("MAE:", mae)
print("R2:", r2)
print("Adjusted R2:", adjusted_r2)
print("MAPE:", mape)

print("\nModel with Polynomial kernel")
print("Training time:", end_time_poly - start_time_poly)
print("RMSE:", rmse_poly)
print("MAE:", mae_poly)
print("R2:", r2_poly)
print("Adjusted R2:", adjusted_r2_poly)
print("MAPE:", mape_poly)

print("\nModel with Linear kernel")
print("Training time:", end_time_linear - start_time_linear)
print("RMSE:", rmse_linear)
print("MAE:", mae_linear)
print("R2:", r2_linear)
print("Adjusted R2:", adjusted_r2_linear)
print("MAPE:", mape_linear)